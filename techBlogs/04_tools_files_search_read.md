# 工具实践（一）文件/检索类：LS/Glob/Grep/Read 的设计取舍

这一章只关注四个最基础、也最常用的工具：**LS、Glob、Grep、Read**。它们决定了 Agent 如何“看见代码”。如果这四个工具不稳定，后面所有能力都会变成空中楼阁。

本章所有细节都能在代码里找到对应实现：

- `tools/builtin/list_files.py`（LS）
- `tools/builtin/search_files_by_name.py`（Glob）
- `tools/builtin/search_code.py`（Grep）
- `tools/builtin/read_file.py`（Read）

## 1. 先定一个原则：安全优先于完整
这些工具都遵循同一个底层原则：**宁可“部分结果”，也不要“失控结果”**。

你会看到很多“看起来保守”的限制：

- 限制返回条数、限制读取行数
- 默认跳过大型目录（如 `node_modules`）
- 搜索超时后直接停止，并明确标记 `partial`

这些限制会让工具“更可控”，也让输出更容易被模型消化。

## 2. LS：安全的目录浏览
LS 在 `list_files.py` 里实现。它不是简单的 `os.listdir`，而是一个带分页、过滤和沙箱保护的浏览器。

关键设计点：

- **默认忽略大目录**：`DEFAULT_IGNORE` 内置了 `node_modules`、`dist`、`.git` 等，避免目录遍历失控。
- **支持分页**：`limit` 最大 200，超出会被标记为 `partial`，并提示 `offset` 继续。
- **隐藏文件控制**：`include_hidden` 默认为 false，避免把 `.` 开头文件当成噪音。
- **忽略规则可控**：支持 `ignore` 传入 glob 模式，自定义过滤。
- **符号链接安全处理**：只允许指向项目根目录内的链接被当作目录访问。
- **排序稳定**：目录优先、文件其次，同类按字母序，确保多次调用结果一致。

返回结构严格遵循协议，`data.entries` 只包含 `{path, type}`，避免一口气塞太多字段。

**插图位置建议**：放在本节之后。

**配图描述**：
“一个目录树示意图，展示 LS 输出：目录在上、文件在下，旁边标注 limit/offset 和 include_hidden 的说明，风格简洁。”

## 3. Glob：面向“文件名”的全局搜索
Glob 解决的问题是：我知道大概的文件类型或路径模式，但不知道具体文件在哪。

在 `search_files_by_name.py` 中，Glob 的设计非常强调“可控搜索”：

- **pattern 必填**，否则直接返回错误
- **结果数量受限**（`limit` 最大 200）
- **搜索防失控**：设定 `MAX_VISITED_ENTRIES=20_000` 和 `MAX_DURATION_MS=2_000`
- **隐藏目录与忽略目录默认不遍历**（`include_hidden`、`include_ignored` 控制）

一个细节很值得注意：Glob 没用 `PurePosixPath.match`，而是自己做了匹配逻辑。原因是 `PurePosixPath.match` 会做“后缀匹配”，可能把 `agents/*.py` 错配到更深层级。它改成了 `fnmatch` 并做了 `*`/`**` 的转换，保证 `*` 不跨目录，只有 `**` 才跨目录。这是典型的“为了可预期而牺牲一点简洁”。

**插图位置建议**：放在本节之后。

**配图描述**：
“一个匹配示意图：左侧是 glob 模式（`*.py`、`**/*.py`），右侧是命中路径示意，强调 `*` 不跨目录、`**` 才跨目录。”

## 4. Grep：面向“内容”的搜索
Grep 是真正把 Agent 带入代码语义的工具。它的实现同时兼顾性能与降级策略。

核心设计点：

- **优先使用 ripgrep**（`rg --json`），速度快、输出结构化
- **不可用时自动回退**到 Python 搜索（会标记为 `partial`）
- **最大结果数限制**（`MAX_RESULTS = 100`）
- **超时控制**（`TIMEOUT_SEC = 2.0`）
- **结果按 mtime 排序**：最近改动的文件优先展示

Grep 的返回会标记 `fallback_used` 或 `aborted_reason`，并在 `text` 中明确说明原因。这让模型能区分“真的没找到”和“结果可能不完整”。

**插图位置建议**：放在本节之后。

**配图描述**：
“一张双轨道流程图：上方是 rg 搜索路径，下方是 Python fallback 路径，两条路径最终汇聚到统一的 matches 输出。”

## 5. Read：真正的“读文件”能力
Read 在 `read_file.py` 中实现，它看起来简单，但细节很重：

- **按行读取**，默认 500 行，最大 2000 行
- **带行号输出**，方便后续 Edit 精确修改
- **二进制检测**：读取前 8KB，遇到 null byte 直接拒绝
- **编码回退**：UTF-8 解码失败时回退到 `errors=replace`，并标记 `partial`
- **mtime 追踪**：如果文件被外部修改，会在输出中提示 `modified_externally`

Read 的结果对编辑工具非常关键，因为它会提供 `file_mtime_ms`，后续写入会依赖这个信息进行乐观锁校验。

**插图位置建议**：放在本节之后。

**配图描述**：
“一个代码片段示意图，行号在左侧，右侧是代码内容，下方有 start_line/limit 的标注，强调分页读取。”

## 6. 这四个工具如何配合
一个典型的探索流程通常是：

1) 用 **LS** 了解目录结构
2) 用 **Glob** 搜索某类文件（如 `**/*.py`、`**/*.md`）
3) 用 **Grep** 搜索关键符号或配置项
4) 用 **Read** 精读目标文件的局部

这种从“结构 → 文件名 → 内容 → 细节”的路径，比直接 Grep 全仓库更稳定，也更省 token。

## 7. 小结
这四个工具的共同点不是“功能多”，而是“有边界”。

- LS 负责安全地“看目录”
- Glob 负责快速“找文件”
- Grep 负责精准“找内容”
- Read 负责可靠“读细节”

它们一起构成了 Agent 的“视觉系统”，也是后续编辑、上下文工程与日志能力的基础。
