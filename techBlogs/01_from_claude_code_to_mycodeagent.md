# 从 Claude Code 到 MyCodeAgent：我为什么要自己写一个 Coding Agent

市面上的编程助手已经足够好用，解决问题的效率也在快速提升。很多时候你只需要给一个自然语言描述，它就能把代码、测试、排错流程拼成一条“工作流”。但越用越顺手，我反而越好奇它们在“顺手”背后到底发生了什么。

我关心的不是一句话的解释，而是工程层面的细节：模型是如何判断应该读哪个文件、什么时候执行命令、工具调用如何拼接成一条稳定的链路、上下文到底怎么管理、长任务为什么容易走偏。这些问题不做一遍，就永远停留在概念层。

所以我做了 MyCodeAgent。它不是为了替代现有工具，而是为了让我能把一个 Agent 从内部拆开、重新组装，并且能在每一个关键步骤上“看见发生了什么”。

## 一个可以被“剖开”的 Agent
MyCodeAgent 在 `README.md` 里被定位为“面向学习与实验的 ReAct 代码代理项目”。它的目标不是炫技，而是可研究、可调试、可验证。这些不是口号，而是具体落在了代码结构里：

- **主循环是显式的**：`agents/codeAgent.py` 的 `CodeAgent.run()` 把“预处理 → 历史管理 → ReAct 循环 → 写入 history”的步骤写成了清晰的流程。你可以跟着代码一路看下去，而不是被一个“黑盒调用”挡在外面。
- **工具调用有统一协议**：`docs/通用工具响应协议.md` 规定了所有工具的输出结构，具体实现分布在 `tools/` 和 `tools/builtin/`。这意味着“工具返回了什么、失败如何表达、日志如何保留”都可追溯。
- **上下文工程是系统能力**：`core/context_engine/` 里有历史管理、摘要压缩、截断策略与 trace 记录。`HistoryManager` 会负责轮次控制与压缩触发，工具输出过长会落盘到 `tool-output/`，避免直接丢失信息。
- **子代理是“受限工具”**：`tools/builtin/task.py` 把子代理封装成一个工具，类型和权限都是显式的（general/explore/plan/summary），避免“神秘能力”的混入。
- **技能系统可被替换与复用**：`skills/` 目录以 `SKILL.md` 作为约定格式，通过 `SkillTool` 统一加载，让扩展能力也能被管理起来。

这些设计让它更像一个实验平台，而不是“给答案就结束”的助手。

## 为什么一定要自己做
很多人会问：既然现成产品这么强，何必自己写？

我的答案很简单：**做过一次，理解才算落地**。比如：

- 为什么有时模型明明应该读文件，却开始“凭感觉补全”？
- 为什么同一个工具调用在不同 Provider 下表现不一致？
- 为什么长对话越久越容易“离题”，压缩策略到底影响了什么？
- 为什么没有日志系统时，排错几乎靠猜？

这些问题靠使用感受很难回答，只有自己实现与调试才能摸到边界。

除此之外，我想要一个可以快速试验的环境。看到某篇文章提到新的上下文策略或者工具约束方式，我希望能马上把它加进来、跑一遍对比。这种“快速实验”的能力，只有自建 Agent 才能做到。

## 结构并不复杂，但关键部件齐全
这个项目不会在第一章就塞一堆术语。你只需要知道它包含了几个关键骨架：

- `agents/codeAgent.py`：ReAct 主循环与工具注册入口
- `tools/` 与 `tools/builtin/`：工具协议与实现
- `core/context_engine/`：历史管理、压缩与截断
- `skills/` 与 `tools/builtin/task.py`：技能与子代理
- `scripts/chat_test_agent.py`：可验证的运行入口

这些结构会构成后续每一章的骨架，我们会一层层拆开、对应到真实代码，讲清楚“为什么这样做、解决了什么问题、代价是什么”。

## 下一章开始真正“拆机”
这一章只回答“为什么做”。下一章会从 ReAct 主循环讲起，说明它如何被实现、如何与工具系统和历史管理协作，以及这套设计对稳定性意味着什么。
