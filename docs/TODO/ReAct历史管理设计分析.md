# Code Agent 历史管理设计分析

## 问题定义

当前 ReAct 设计的问题：
- Thought/Action/Observation 只在 scratchpad（本轮）
- history 只记录最终 Finish 结果
- 下一轮 scratchpad 清空，模型不记得上一轮的工具结果

---

## 当前设计的优劣分析

### ✅ 优点

| 方面 | 说明 |
|------|------|
| **简洁性** | 每轮独立，状态清晰，易于理解和调试 |
| **上下文节省** | 不会累积过多历史，避免上下文窗口爆炸 |
| **无副作用** | 每轮从干净状态开始，避免状态污染 |
| **符合标准 ReAct** | 遵循原始 ReAct 论文的设计理念 |

### ❌ 缺点

| 问题 | 影响 |
|------|------|
| **工具结果丢失** | 上一轮 Read 的文件内容、Edit 的修改结果，下一轮完全不知道 |
| **重复操作** | 模型可能重复读取同一文件，浪费 token 和时间 |
| **上下文断裂** | 无法进行"先读后改再验证"这类多步骤任务 |
| **调试困难** | 无法追溯之前工具调用的具体结果 |

---

## 主流 Code Agent 的解决方案

### 1. Claude Code：完整保留 + 智能压缩

```python
# 工具调用结果自动添加到对话历史
messages.append({
    "role": "assistant",
    "content": "使用 Read 工具读取了文件",
    "tool_calls": [...],
    "tool_results": [...]  # 关键：结果被保留
})
```

**核心策略**：
- 200K 上下文窗口，完整保留工具结果
- 接近限制时自动压缩早期对话
- 通过 `/context` 命令查看使用情况

**优点**：模型始终知道文件当前状态
**缺点**：上下文膨胀快

---

### 2. Cursor：影子工作区 + 增量同步

```
用户工作区 ←→ 影子工作区 ←→ Agent
     ↑                              ↓
  实时监控                    AI 在隔离环境实验
```

**核心策略**：
- 维护文件系统的 Merkle 树（基于内容哈希）
- 只同步变更部分（增量更新）
- 检查点系统支持快速回滚

**优点**：安全性极高，高效同步
**缺点**：架构复杂

---

### 3. OpenInterpreter：真实执行状态

```python
# 保持真实的 Python 解释器状态
interpreter = PythonInterpreter()
interpreter.execute(code)  # 真实执行，状态持久化
```

**核心策略**：
- 真实执行环境，状态通过查询而非记忆获取
- 文件系统监控实时跟踪变化
- 执行结果摘要避免长输出

**优点**：状态准确性高，无"不记得"问题
**缺点**：资源消耗大

---

### 4. AutoGPT：混合记忆架构

```
短期记忆（上下文）+ 长期记忆（向量数据库）
      ↓                    ↓
   当前对话            历史经验检索
```

**核心策略**：
- 短期：当前任务的完整上下文
- 长期：向量化存储历史经验，按需检索
- 记忆固定：重要信息固定在上下文开始

**优点**：跨会话记忆，任务管理强
**缺点**：检索可能不准确

---

## 推荐方案：双轨记忆 + 增量摘要

```
┌─────────────────────────────────────────────────────────────┐
│                      Agent History                           │
│  (完整的用户/assistant 对话，包含最终结果)                    │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                   Tool Summary Layer                         │
│  - 文件读取：记录"已读取: file.py (行1-50)"                  │
│  - 文件修改：记录"已修改: file.py (函数X增加新参数)"           │
│  - 搜索结果：记录"在 3 个文件中找到 'pattern'"               │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                   Scratchpad (每轮清空)                      │
│  - Thought/Action/Observation（本轮 ReAct 过程）              │
└─────────────────────────────────────────────────────────────┘
```

### 实现要点

| 层级 | 内容 | 保留策略 |
|------|------|---------|
| **Agent History** | 完整对话 | 永久保留 |
| **Tool Summary** | 工具操作摘要 | N 轮后压缩 |
| **Scratchpad** | 当前 ReAct 过程 | 每轮清空 |

### 关键改进

1. **工具结果摘要化**
   ```python
   # 当前：Observation: {完整的 JSON 响应}
   # 改进：Observation: 读取了 main.py (共 150 行)
   #        详情已记录到工具摘要，可按需查询
   ```

2. **智能历史注入**
   ```python
   def build_prompt():
       prompt = ReAct_template
       # 注入最近 N 轮的工具摘要
       prompt += "\n## 最近的文件操作\n"
       prompt += format_tool_summary(recent_tools)
       # 当前 scratchpad
       prompt += format_scratchpad(self.scratchpad)
   ```

3. **按需详情恢复**
   ```python
   # 当模型需要具体内容时
   if user_asked_about("main.py 具体内容"):
       # 从历史中提取之前的 Read 结果
       previous_result = history.get_tool_result("Read", "main.py")
       scratchpad.append(f"Context: {previous_result}")
   ```

---

## 实现优先级

| 优先级 | 改进项 | 复杂度 | 效果 |
|--------|--------|--------|------|
| P0 | 工具摘要层 | 中 | 解决"不记得修改"问题 |
| P1 | 智能历史注入 | 低 | 提升上下文质量 |
| P2 | 按需详情恢复 | 高 | 减少重复操作 |
| P3 | 自动压缩 | 高 | 长对话支持 |

---

## 总结

当前设计（清空 scratchpad）本身没错，问题在于**缺少中间状态的记忆机制**。

建议：保持 ReAct 每轮独立，但增加一个**工具摘要层**，在简洁和记忆之间取得平衡。
