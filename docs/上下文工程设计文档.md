# 上下文工程方案（定稿版）

> 本文档面向 **Agent** 与 **人类审阅者**。
> Agent 部分仅包含已确定规则（无实施计划、无待定项），保证清晰、可执行、无歧义。

---
相关提示词已经放在prompts目录下，不需要自己编写，可以按照情况进行调整使用。
## A. Agent 规则（必须遵守）

### A1. 分层结构与注入顺序
- **L1 系统静态层**：System Prompt + 工具提示词（固定前缀，稳定）
- **L2 项目规则层**：`CODE_LAW.md`（有则注入，无则为空；不进入 history）
- **L3 会话历史层**：user / assistant / tool 消息 + system summary

**上下文拼接顺序**：
1) L1（System + Tools）
2) L2（CODE_LAW.md）
3) L3（history）
4) 当前 user 输入（本轮）
5) Todo recap（若有）

> system summary 属于 L3，不属于 L1。

---

### A2. ReAct 行为与历史写入（方案 B）
- **当前推理**使用完整 Observation（scratchpad）。
- **历史写入**仅保留压缩版行动记录。

用户输入问题
模型组装好 上下文 l1 + l2 + l3（history） + 当前 user 输入（本轮）
模型开始react流程
react里面有个临时历史，记录完整的模型 think -action - observation 过程，
直到认为finish 才停止react流程。 可以清空临时历史了
在写入 临时历史的时候，也应该进行压缩并存入history。
存入history message就像这样
messsage(assisant , "Thought :xxx Action :xxx")
message(tools,"tools response （压缩过的）") // 这个不就是 observation 吗
messsage(assisant , "Thought :xxx Action :xxx") 
message(tools,"tools response （压缩过的）")
message(assisant , "Finish") 

---

### A3. 工具输出压缩规则（写入 history 用）
> Observation 给模型时保持完整，写入 history 时使用压缩版。

| 工具 | 历史写入压缩策略 | 备注 |
|---|---|---|
| **LS** | 目录 + 统计 + 前 N 项 | 不保留全量列表 |
| **Glob** | pattern + 命中数 + 前 N 项 | 命中多时保留前 5-10 |
| **Grep** | 摘要 + 前 N 条匹配行 | N = 5（含文件名+行号） |
| **Read** | 保留片段内容（带行号） | 上限 500 行，仅当前区间 |
| **Edit / MultiEdit** | 变更摘要（文件 + 变更区间 + 关键片段） | 大 diff 仅保留摘要 |
| **Write** | 变更摘要（文件 + 新增/覆盖 + 片段） | 新文件保留前 20-50 行 |
| **Bash** | 摘要 + stderr 尾部 | stderr 末尾 20 行，stdout 仅摘要 |
| **TodoWrite** | 仅保留 recap | 不保留完整列表 |

默认上限：
- Read：最多 500 行
- Grep：最多 5 行
- Edit/Write 片段：20-50 行

---

### A4. 历史压缩（History Compaction）
- **只压缩** user / assistant / tool 消息。
- **system summary 不参与压缩**，只追加。
- **工具调用完整性**：tool_use / tool_result 必须成对保留，不得拆分。

**保留区规则（非固定 10 轮）**：
- **至少保留最近 10 轮**，但允许多于 10 轮。
- “一轮”定义：从 **user 发起** 到 **assistant 完成回答**（中间允许多次工具调用）。
- 压缩边界必须对齐到**完整轮次**，不能切断一轮。

---

### A5. Summary 规则（旧历史归档）
- Summary 只用于**旧历史归档**，不包含当前任务进度。
- Summary 以 **system message** 写入 L3。
- Summary **不会被再次压缩**。

**Summary 模板（固定）**：
```
## 📌 Archived Session Summary
*(Contains context from [Start Time] to [Cutoff Time])*

### 🎯 Objectives & Status
* **Original Goal**: [用户最初想做什么]

### 🏗️ Technical Context (Static)
* **Stack**: [语言, 框架, 版本]
* **Environment**: [OS, Shell,关键环境变量]

### ✅ Completed Milestones (The "Done" Pile)
* [✓] [已完成的任务1] - [简述结果]
* [✓] [已完成的任务2] - [简述结果]

### 🧠 Key Insights & Decisions (Persistent Memory)
* **Decisions**: [关键技术选型或放弃的方案]
* **Learnings**: [特殊配置、API 格式或坑]
* **User Preferences**: [用户强调的习惯]

### 📂 File System State (Snapshot)
*(Modified files in this archive segment)*
* `src/utils/auth.ts`: Implemented login logic.
* `package.json`: Added `zod` dependency.
```

---

### A6. Token 触发规则
- **Token 来源**：上一次 API 调用的 `usage`（精确）
- **前置估算**：当前 user 输入 `len(text)//3`
- **Context Window**：固定 200k
- **阈值**：`0.8 × 200k`
- **最低消息数**：至少 3 条消息才考虑压缩

判断公式：
```
estimated_total = last_usage + estimate(user_input)
compress if estimated_total >= 0.8 * 200k
```

---

### A7. @file 处理（Kode 风格）
**原则**：@file 只触发提醒，不注入文件内容；必须先 Read。

**流程**：
1) 解析 `@path`
2) 注入 system-reminder（不含文件内容）
3) 模型调用 Read 获取内容
4) Read 结果进入 history（含 mtime）

**system-reminder 模板**：
```
<system-reminder>
The user mentioned @src/utils/auth.ts.
You MUST read this file with the Read tool before answering.
</system-reminder>
```

**正则（MVP）**：`@([a-zA-Z0-9/._-]+(?:\.[a-zA-Z0-9]+)?)`
- 只匹配项目内相对路径（不支持空格）
- 命中前一字符若为字母/数字，则视为非文件引用

**多文件策略**：
- 按出现顺序、去重
- 最多 5 个，超出提示 “(and N more…)”

---

### A8. 文件新鲜度（轻量提醒）
- 不做全局文件新鲜度/自动刷新
- Read 返回 mtime；**再次读取同一文件**且 mtime 变化时追加提示：
  - `Note: <file> was modified externally.`

---

## B. 人类可读版说明（完整）

我们做上下文工程的核心目标是让模型在长对话里依然稳定、不会爆窗、也不会丢关键事实。所以我把上下文拆成三层：L1 是固定的系统提示词和工具提示词，保证前缀稳定；L2 是项目规则文件 CODE_LAW.md，有就注入，没有就空，不进入历史；L3 是会话历史，包括用户、助手、工具消息和压缩摘要。模型每一步 ReAct 的推理需要完整的工具返回，因此这些 Observation 会进入临时 scratchpad；但写回历史时只保存压缩版的行动记录（Reason/Action/Observation/Decision），这样既能追踪做了什么，又不会让历史无限膨胀。

当历史太长时，我们只压缩 user/assistant/tool 消息，summary 永远不会再压缩；同时必须保证 tool_use 和 tool_result 成对保留，不允许切断。保留区不是硬性 10 轮，而是“至少 10 轮且保证完整任务轮次”，也就是从用户发起到助手完成的完整一轮。@file 的处理是：用户提到 @path 时不直接注入文件内容，而是插入 system-reminder，强制模型调用 Read；Read 返回 mtime，如果下一次读发现外部修改，就提示模型。整体上就是让推理用完整、记忆用精简，保证可追踪、可扩展、可长期运行。

---

## C. 实施细节（Implementation Details）

### C1. 工具返回压缩规则（写入 history 时）
**压缩执行位置**：在历史管理模块写入 history 时执行（代码规则化压缩，非 agent）

**保留字段**：
- `status`：必须保留（模型需要知道是否成功）
- `data`：按 A3 表格规则压缩（截断列表、保留摘要、保留状态标记如 `truncated` / `applied` / `fallback`）
- `error`：若 `status === "error"`，完整保留 `error.code` 和 `error.message`

**丢弃字段**：
- `text`：丢弃（已包含在 data 压缩版中）
- `stats`：丢弃（性能指标对 agent 推理无用）
- `context`：丢弃（调用参数已在 tool_use 中）

**后续升级路径**：可选引入 subagent 进行语义压缩。

---

### C2. Summary 生成机制
- **触发时机**：历史压缩时（token 超阈值）
- **实现方式**：调用新的模型会话（可配置模型，默认使用当前模型）
- **输入**：待压缩的 history messages + `SUMMARY_PROMPT`（位于 `prompts/agents_prompts/summary_prompt.py`）
- **输出**：按 A5 模板生成的 Summary（写入 L3 作为 system message）
- **用户体验**：同步阻塞，用户看到压缩进度提示，等待压缩完成后才能继续对话

---

### C3. @file 处理流程
- **解析**：正则匹配 `@([a-zA-Z0-9/._-]+(?:\.[a-zA-Z0-9]+)?)`（项目内相对路径，不支持空格）
- **改写位置**：在 user message 预处理阶段执行
- **改写方式**：在 user message 内容中追加 system-reminder 文本（不作为独立的 system message）
- **模板**：
  ```
  <system-reminder>
  The user mentioned @src/utils/auth.ts.
  You MUST read this file with the Read tool before answering.
  </system-reminder>
  ```
- **多文件**：按出现顺序、去重、最多 5 个，超出提示 "(and N more…)"
- **Read 调用**：模型必须按顺序逐个调用 Read 工具获取内容

---

### C4. mtime 追踪机制
- **存储位置**：内存字典 `{filepath: last_mtime}`（不持久化）
- **触发条件**：再次读取同一文件且 mtime 变化时
- **提示方式**：在 Read 工具返回的 `data` 中追加提示字段或在 text 中提示：
  ```
  Note: <file> was modified externally.
  ```

---

### C5. CODE_LAW.md 查找规则
- **位置**：项目根目录
- **文件名**：`CODE_LAW.md` 或 `code_law.md`（大小写不敏感）
- **注入时机**：每次拼接上下文时（L2 层）
- **注入方式**：有则注入，无则为空；不进入 history

---

### C6. 保留区配置
- **默认值**：至少保留最近 10 轮
- **可配置**：可通过配置文件或环境变量调整
- **轮次定义**：从 user 发起到 assistant 完成回答（中间允许多次工具调用）
- **压缩边界**：必须对齐到完整轮次，不能切断一轮
- **特殊情况**：压缩后不会超过阈值（方案已保证）

---

### C7. 压缩触发时机
- **Token 来源**：上一次 API 调用的 `usage`（精确值）
- **前置估算**：当前 user 输入 `len(text)//3`
- **Context Window**：固定 200k
- **阈值**：`0.8 × 200k = 160k`
- **最低消息数**：至少 3 条消息才考虑压缩

**判断公式**：
```python
estimated_total = last_usage + estimate(user_input)
if estimated_total >= 0.8 * 200_000 and len(messages) >= 3:
    trigger_compression()
```

---

### C8. B 节更新说明
在 B 节人类可读版的基础上，补充以下实施细节：
- **工具压缩**：写入 history 时只保留 status + data（按 A3 压缩）+ error，丢弃 text/stats/context
- **历史压缩**：调用新模型会话生成 Summary（同步阻塞，用户看到进度）
- **@file 改写**：在 user message 中追加 system-reminder 文本（不作为独立 system message）
- **mtime 追踪**：内存字典，不持久化
- **CODE_LAW.md**：项目根目录，大小写不敏感
- **保留区**：默认 10 轮可配置，边界对齐完整轮次

---

## D. 实施方案（任务拆解）

### D1. 数据模型与历史记录
- 沿用 Message(role/content/metadata)；新增约定：tool 消息 content 为压缩后的 JSON 字符串，assistant 步进消息 content 为模型原文 Thought/Action，metadata 可存辅助信息（step、tool_name 等）。
- 一轮边界通过模式匹配：遇到 user 消息即开启新轮；压缩时按完整轮次切片，保留至少最近 10 轮（可配置）。

### D2. 新增/改造模块
1) **HistoryManager（新增）**
   - 职责：
     - 轮内写入：在 ReAct 每一步同步写入 assistant（Thought/Action）与 tool（压缩结果）消息。
     - 轮间管理：提供 append/get/compact 接口；基于 user 消息分轮；执行压缩（A3 规则）；触发 Summary 生成并插入 summary 消息。
   - 压缩策略：调用 ToolResultCompressor（见 D3）；仅保留 status + 压缩 data + error，丢弃 text/stats/context。
2) **ToolResultCompressor（新增）**
   - 根据 tool_name 应用 A3 规则（Read/Grep/LS/Glob/Edit/Write/MultiEdit/Bash/TodoWrite）。
   - 提供默认回退策略（截断/摘要）。
3) **InputPreprocessor（新增）**
   - 解析 @file，按出现顺序、去重、最多 5 个；在 user message 内容追加 system-reminder 文本（不生成 system 消息）；超出提示 "(and N more…)"。
4) **SummaryCompressor（新增）**
   - 封装调用 LLM 生成 Summary（使用 SUMMARY_PROMPT，可配置模型）；同步阻塞，返回 summary Message(role="summary")。

### D3. CodeAgent 流程调整
- run():
  - 先对 input_text 运行 InputPreprocessor；不将本轮 user 写入 history。
  - 进入 ReAct：
    - 每步：
      1) 组装上下文（ContextBuilder，见 D4），调用 LLM，得到 Thought/Action → 立刻写入 assistant 消息到 history。
      2) 若调用工具：执行工具，得到 full_result → ToolResultCompressor 压缩 → 写入 tool 消息到 history；同时将完整 Observation 记录到 scratchpad 供本轮后续推理。
    - Finish 时：写入最终 assistant 消息到 history，返回给用户。
- 轮结束后 scratchpad 清空；history 保留用于下一轮。

### D4. ContextBuilder 调整
- 接口改为接收 `history: List[Message]` + `scratchpad: List[str]` + `question`。
- 拼接顺序：L1(system+tools) → L2(CODE_LAW) → L3(history 压缩版字符串) → 当前 user 输入（预处理后的 input_text） → Todo recap（若有）。
- history 转字符串时保持角色标签，tool 消息使用压缩 JSON 片段，summary 消息原样插入。

### D5. mtime 追踪
- ReadTool 内部维护 `{filepath: last_mtime}` 字典（内存）；再次读取且 mtime 变化时在 data/text 增加提醒。

### D6. 压缩与 Summary 触发
- 在收到新 user 输入时检查 token 预算（last_usage + len(user_input)//3）；达到阈值且消息数≥3则触发 HistoryManager.compact：
  1) 按轮裁剪需压缩段。
  2) 生成 Summary（SummaryCompressor）。
  3) 压缩旧消息并插入 summary，保留完整配对的 tool 调用。

### D7. 任务拆分与交付顺序
1) 引入 ToolResultCompressor + 基础压缩规则单测。
2) 引入 HistoryManager，接管写入/压缩/分轮逻辑（模式匹配 user 开新轮）。
3) 重构 CodeAgent：接线 HistoryManager、逐步写入消息、保留 scratchpad、调整 run 流程。
4) 添加 InputPreprocessor，改造 run 输入预处理。
5) 调整 ContextBuilder 接口与拼接逻辑，适配 Message 列表。
6) ReadTool mtime 追踪。
7) SummaryCompressor 集成压缩触发路径。
8) 回归测试：核心流程（无工具/有工具/多轮/压缩触发）、工具压缩规则、@file 预处理、mtime 提醒、Summary 生成路径。

---

## E. 设计决策补充（Implementation Decisions）

### E1. tool 消息序列化格式
- **存储**：`Message(role="tool", content=压缩后的JSON字符串, metadata={"tool_name": "Read", "step": 3})`
- **序列化到 prompt**：不使用 OpenAI function calling 协议，直接拼成 ReAct 文本格式：
  ```
  [assistant] Thought: xxx
  Action: ToolName[{...}]

  [tool] {"status": "success", "data": {...}}

  [assistant] Thought: xxx
  Action: Finish[...]
  ```
- **理由**：项目使用 ReAct 文本格式（Thought/Action/Observation），不依赖 OpenAI tool_call_id

### E2. Summary 生成超时与降级
- **超时限制**：120 秒（2 分钟）
- **降级策略**：超时则跳过 Summary 生成，仅做硬截断保留最近 N 轮
- **用户提示**：超时时显示 "Summary generation timed out, keeping recent history only."

### E3. ContextBuilder 改造策略
- **策略**：完全重写 `build()` 方法，不保留旧接口兼容
- **新签名**：`build(history: List[Message], scratchpad: List[str], question: str) -> str`
- **理由**：当前代码为 demo 阶段，允许破坏性重构

### E4. @file 正则限制
- **MVP 限制**：仅支持英文路径，不支持中文、空格、特殊字符
- **正则**：`@([a-zA-Z0-9/._-]+(?:\.[a-zA-Z0-9]+)?)`
- **后续扩展**：如需支持中文路径，可改用 `@"path with spaces"` 引号语法

### E5. context_window 可配置
- **配置来源**：从 `Config` 类读取 `context_window` 字段
- **默认值**：200,000 tokens
- **阈值计算**：`threshold = 0.8 * config.context_window`
