# 上下文工程方案（定稿版）

> 本文档面向 **Agent** 与 **人类审阅者**。
> Agent 部分仅包含已确定规则（无实施计划、无待定项），保证清晰、可执行、无歧义。

---
相关提示词已经放在prompts目录下，不需要自己编写，可以按照情况进行调整使用。
## A. Agent 规则（必须遵守）

### A1. 分层结构与注入顺序
- **L1 系统静态层**：System Prompt + 工具提示词（固定前缀，稳定）
- **L2 项目规则层**：`CODE_LAW.md`（有则注入，无则为空；不进入 history）
- **L3 会话历史层**：user / assistant / tool 消息 + system summary

**上下文拼接顺序**：
1) L1（System + Tools）
2) L2（CODE_LAW.md）
3) L3（history）
4) 当前 user 输入（本轮）
5) Todo recap（若有）

> system summary 属于 L3，不属于 L1。

---

### A2. ReAct 行为与历史写入（方案 B）
- **当前推理**使用完整 Observation（scratchpad）。
- **历史写入**仅保留截断版行动记录。

用户输入问题
模型组装好 上下文 l1 + l2 + l3（history） + 当前 user 输入（本轮）
模型开始react流程
react里面有个临时历史，记录完整的模型 think -action - observation 过程，
直到认为finish 才停止react流程。 可以清空临时历史了
在写入临时历史的时候，也应该进行截断并存入 history。
存入history message就像这样
messsage(assisant , "Thought :xxx Action :xxx")
message(tools,"tools response （截断后）") // 这个不就是 observation 吗
messsage(assisant , "Thought :xxx Action :xxx") 
message(tools,"tools response （截断后）")
message(assisant , "Finish") 

---

### A3. 工具输出截断规则（统一策略）
> Observation 写入模型前统一截断；history 直接写入截断后的结果。

统一截断策略（适用于所有工具）：
- `MAX_LINES = 2000`
- `MAX_BYTES = 50KB`
- 方向：`head`（默认）或 `tail`

处理流程：
1) 行数 ≤ MAX_LINES 且字节数 ≤ MAX_BYTES → 原样返回  
2) 否则 → 截断 + 落盘保存完整输出 + 返回提示路径  

跳过机制（可选）：
- 当 `context.truncation_skip = true` 时，放行原始输出

完整规范参见：`docs/工具输出截断设计文档.md`

---

### A4. 历史压缩（History Compaction）
- **只压缩** user / assistant / tool 消息。
- **system summary 不参与压缩**，只追加。
- **工具调用完整性**：tool_use / tool_result 必须成对保留，不得拆分。

**保留区规则（非固定 10 轮）**：
- **至少保留最近 10 轮**，但允许多于 10 轮。
- “一轮”定义：从 **user 发起** 到 **assistant 完成回答**（中间允许多次工具调用）。
- 压缩边界必须对齐到**完整轮次**，不能切断一轮。

---

### A5. Summary 规则（旧历史归档）
- Summary 只用于**旧历史归档**，不包含当前任务进度。
- Summary 以 **system message** 写入 L3。
- Summary **不会被再次压缩**。

**Summary 模板（固定）**：
```
## 📌 Archived Session Summary
*(Contains context from [Start Time] to [Cutoff Time])*

### 🎯 Objectives & Status
* **Original Goal**: [用户最初想做什么]

### 🏗️ Technical Context (Static)
* **Stack**: [语言, 框架, 版本]
* **Environment**: [OS, Shell,关键环境变量]

### ✅ Completed Milestones (The "Done" Pile)
* [✓] [已完成的任务1] - [简述结果]
* [✓] [已完成的任务2] - [简述结果]

### 🧠 Key Insights & Decisions (Persistent Memory)
* **Decisions**: [关键技术选型或放弃的方案]
* **Learnings**: [特殊配置、API 格式或坑]
* **User Preferences**: [用户强调的习惯]

### 📂 File System State (Snapshot)
*(Modified files in this archive segment)*
* `src/utils/auth.ts`: Implemented login logic.
* `package.json`: Added `zod` dependency.
```

---

### A6. Token 触发规则
- **Token 来源**：上一次 API 调用的 `usage`（精确）
- **前置估算**：当前 user 输入 `len(text)//3`
- **Context Window**：默认 10k（可通过环境变量调整）
- **阈值**：`0.8 × context_window`
- **最低消息数**：至少 3 条消息才考虑压缩

判断公式：
```
estimated_total = estimate(current_context + user_input)
compress if estimated_total >= 0.8 * context_window
```

---

### A7. @file 处理（Kode 风格）
**原则**：@file 只触发提醒，不注入文件内容；必须先 Read。

**流程**：
1) 解析 `@path`
2) 注入 system-reminder（不含文件内容）
3) 模型调用 Read 获取内容
4) Read 结果进入 history（含 mtime）

**system-reminder 模板**：
```
<system-reminder>
The user mentioned @src/utils/auth.ts.
You MUST read this file with the Read tool before answering.
</system-reminder>
```

**正则（MVP）**：`@([a-zA-Z0-9/._-]+(?:\.[a-zA-Z0-9]+)?)`
- 只匹配项目内相对路径（不支持空格）
- 命中前一字符若为字母/数字，则视为非文件引用

**多文件策略**：
- 按出现顺序、去重
- 最多 5 个，超出提示 “(and N more…)”

---

### A8. 文件新鲜度（轻量提醒）
- 不做全局文件新鲜度/自动刷新
- Read 返回 mtime；**再次读取同一文件**且 mtime 变化时追加提示：
  - `Note: <file> was modified externally.`

---

## B. 人类可读版说明（完整）

我们做上下文工程的核心目标是让模型在长对话里依然稳定、不会爆窗、也不会丢关键事实。所以我把上下文拆成三层：L1 是固定的系统提示词和工具提示词，保证前缀稳定；L2 是项目规则文件 CODE_LAW.md，有就注入，没有就空，不进入历史；L3 是会话历史，包括用户、助手、工具消息和压缩摘要。工具输出在写入 history 前统一截断（必要时落盘），这样既能追踪做了什么，又不会让历史无限膨胀。

当历史太长时，我们只压缩 user/assistant/tool 消息，summary 永远不会再压缩；同时必须保证 tool_use 和 tool_result 成对保留，不允许切断。保留区不是硬性 10 轮，而是“至少 10 轮且保证完整任务轮次”，也就是从用户发起到助手完成的完整一轮。@file 的处理是：用户提到 @path 时不直接注入文件内容，而是插入 system-reminder，强制模型调用 Read；Read 返回 mtime，如果下一次读发现外部修改，就提示模型。整体上就是让推理用完整、记忆用精简，保证可追踪、可扩展、可长期运行。

---

## C. 实施细节（Implementation Details）

### C1. 工具输出截断规则（写入 history 时）
**截断执行位置**：在历史管理模块写入 history 前执行（统一截断，非按工具定制）。

**统一规则**（见 A3 / `docs/工具输出截断设计文档.md`）：
- 超过 `MAX_LINES` 或 `MAX_BYTES` 即截断
- 完整输出落盘保存
- 返回截断提示与完整路径

**字段处理**：
- 不再做按工具特化压缩
- 若触发截断，`status = "partial"`（除非原本为 error）

---

### C2. Summary 生成机制
- **触发时机**：历史压缩时（token 超阈值）
- **实现方式**：调用新的模型会话（可配置模型，默认使用当前模型）
- **输入**：待压缩的 history messages + `SUMMARY_PROMPT`（位于 `prompts/agents_prompts/summary_prompt.py`）
- **输出**：按 A5 模板生成的 Summary（写入 L3 作为 system message）
- **用户体验**：同步阻塞，用户看到压缩进度提示，等待压缩完成后才能继续对话

---

### C3. @file 处理流程
- **解析**：正则匹配 `@([a-zA-Z0-9/._-]+(?:\.[a-zA-Z0-9]+)?)`（项目内相对路径，不支持空格）
- **改写位置**：在 user message 预处理阶段执行
- **改写方式**：在 user message 内容中追加 system-reminder 文本（不作为独立的 system message）
- **模板**：
  ```
  <system-reminder>
  The user mentioned @src/utils/auth.ts.
  You MUST read this file with the Read tool before answering.
  </system-reminder>
  ```
- **多文件**：按出现顺序、去重、最多 5 个，超出提示 "(and N more…)"
- **Read 调用**：模型必须按顺序逐个调用 Read 工具获取内容

---

### C4. mtime 追踪机制
- **存储位置**：内存字典 `{filepath: last_mtime}`（不持久化）
- **触发条件**：再次读取同一文件且 mtime 变化时
- **提示方式**：在 Read 工具返回的 `data` 中追加提示字段或在 text 中提示：
  ```
  Note: <file> was modified externally.
  ```

---

### C5. CODE_LAW.md 查找规则
- **位置**：项目根目录
- **文件名**：`CODE_LAW.md` 或 `code_law.md`（大小写不敏感）
- **注入时机**：每次拼接上下文时（L2 层）
- **注入方式**：有则注入，无则为空；不进入 history

---

### C6. 保留区配置
- **默认值**：至少保留最近 10 轮
- **可配置**：可通过配置文件或环境变量调整
- **轮次定义**：从 user 发起到 assistant 完成回答（中间允许多次工具调用）
- **压缩边界**：必须对齐到完整轮次，不能切断一轮
- **特殊情况**：压缩后不会超过阈值（方案已保证）

---

### C7. 压缩触发时机
- **Token 来源**：上一次 API 调用的 `usage`（精确值）
- **前置估算**：当前 user 输入 `len(text)//3`
- **Context Window**：默认 10k（可通过环境变量调整）
- **阈值**：`0.8 × context_window`
- **最低消息数**：至少 3 条消息才考虑压缩

**判断公式**：
```python
estimated_total = estimate(current_context + user_input)
if estimated_total >= 0.8 * 200_000 and len(messages) >= 3:
    trigger_compression()
```

---

### C8. B 节更新说明
在 B 节人类可读版的基础上，补充以下实施细节：
- **工具截断**：写入 history 前统一截断工具输出（见 A3），必要时落盘并提示路径
- **历史压缩**：调用新模型会话生成 Summary（同步阻塞，用户看到进度）
- **@file 改写**：在 user message 中追加 system-reminder 文本（不作为独立 system message）
- **mtime 追踪**：内存字典，不持久化
- **CODE_LAW.md**：项目根目录，大小写不敏感
- **保留区**：默认 10 轮可配置，边界对齐完整轮次

---

## D. 实施方案（任务拆解）

### D1. 数据模型与历史记录
- 沿用 Message(role/content/metadata)；新增约定：tool 消息 content 为截断后的 JSON 字符串，assistant 步进消息 content 为模型原文 Thought/Action，metadata 可存辅助信息（step、tool_name 等）。
- 一轮边界通过模式匹配：遇到 user 消息即开启新轮；压缩时按完整轮次切片，保留至少最近 10 轮（可配置）。

### D2. 新增/改造模块
1) **HistoryManager（新增）**
   - 职责：
     - 轮内写入：在 ReAct 每一步同步写入 assistant（Thought/Action）与 tool（截断结果）消息。
     - 轮间管理：提供 append/get/compact 接口；基于 user 消息分轮；触发 Summary 生成并插入 summary 消息。
2) **ObservationTruncator（新增）**
   - 统一截断策略（A3），不区分工具类型。
   - 超限落盘保存完整输出，并在结果中提示路径。
3) **InputPreprocessor（新增）**
   - 解析 @file，按出现顺序、去重、最多 5 个；在 user message 内容追加 system-reminder 文本（不生成 system 消息）；超出提示 "(and N more…)"。
4) **SummaryCompressor（新增）**
   - 封装调用 LLM 生成 Summary（使用 SUMMARY_PROMPT，可配置模型）；同步阻塞，返回 summary Message(role="summary")。

### D3. CodeAgent 流程调整
- run():
  - 先对 input_text 运行 InputPreprocessor；不将本轮 user 写入 history。
  - 进入 ReAct：
    - 每步：
      1) 组装上下文（ContextBuilder，见 D4），调用 LLM，得到 Thought/Action → 立刻写入 assistant 消息到 history。
      2) 若调用工具：执行工具，得到 full_result → ObservationTruncator 统一截断 → 写入 tool 消息到 history。
    - Finish 时：写入最终 assistant 消息到 history，返回给用户。
- 轮结束后 scratchpad 清空；history 保留用于下一轮。

### D4. ContextBuilder 调整
- 接口改为接收 `history: List[Message]` + `scratchpad: List[str]` + `question`。
- 拼接顺序：L1(system+tools) → L2(CODE_LAW) → L3(history 压缩版字符串) → 当前 user 输入（预处理后的 input_text） → Todo recap（若有）。
- history 转字符串时保持角色标签，tool 消息使用截断 JSON 片段，summary 消息原样插入。

### D5. mtime 追踪
- ReadTool 内部维护 `{filepath: last_mtime}` 字典（内存）；再次读取且 mtime 变化时在 data/text 增加提醒。

### D6. 压缩与 Summary 触发
- 在每次 ReAct 前检查 token 预算（历史消息 + user_input 的估算）；达到阈值且消息数≥3则触发 HistoryManager.compact：
  1) 按轮裁剪需压缩段。
  2) 生成 Summary（SummaryCompressor）。
  3) 压缩旧消息并插入 summary，保留完整配对的 tool 调用。

### D7. 任务拆分与交付顺序
1) 引入 ObservationTruncator + 统一截断规则单测。
2) 引入 HistoryManager，接管写入/压缩/分轮逻辑（模式匹配 user 开新轮）。
3) 重构 CodeAgent：接线 HistoryManager、逐步写入消息、保留 scratchpad、调整 run 流程。
4) 添加 InputPreprocessor，改造 run 输入预处理。
5) 调整 ContextBuilder 接口与拼接逻辑，适配 Message 列表。
6) ReadTool mtime 追踪。
7) SummaryCompressor 集成压缩触发路径。
8) 回归测试：核心流程（无工具/有工具/多轮/压缩触发）、工具截断规则、@file 预处理、mtime 提醒、Summary 生成路径。

---

## E. 设计决策补充（Implementation Decisions）

### E1. tool 消息序列化格式
- **存储**：`Message(role="tool", content=截断后的JSON字符串, metadata={"tool_name": "Read", "tool_call_id": "call_xxx"})`
- **序列化到 prompt**：使用 OpenAI function calling 规范（assistant.tool_calls + tool role）：
  ```
  [assistant] content: ""
  tool_calls: [{id: "call_xxx", type: "function", function: {name: "Read", arguments: "{...}"}}]

  [tool] tool_call_id: "call_xxx"
  {"status": "success", "data": {...}}
  ```
- **理由**：全链路统一为 function calling，避免 Action 文本解析与 tool_call_id 缺失问题

### E2. Summary 生成超时与降级
- **超时限制**：120 秒（2 分钟）
- **降级策略**：超时则跳过 Summary 生成，仅做硬截断保留最近 N 轮
- **用户提示**：超时时显示 "Summary generation timed out, keeping recent history only."

### E3. ContextBuilder 改造策略
- **策略**：完全重写 `build()` 方法，不保留旧接口兼容
- **新签名**：`build(history: List[Message], scratchpad: List[str], question: str) -> str`
- **理由**：当前代码为 demo 阶段，允许破坏性重构

### E4. @file 正则限制
- **MVP 限制**：仅支持英文路径，不支持中文、空格、特殊字符
- **正则**：`@([a-zA-Z0-9/._-]+(?:\.[a-zA-Z0-9]+)?)`
- **后续扩展**：如需支持中文路径，可改用 `@"path with spaces"` 引号语法

### E5. context_window 可配置
- **配置来源**：从 `Config` 类读取 `context_window` 字段
- **默认值**：200,000 tokens
- **阈值计算**：`threshold = 0.8 * config.context_window`
