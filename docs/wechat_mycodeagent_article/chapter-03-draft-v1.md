# 第3章：第一个大坑——Terminal Tool 为什么会失控

V0 做出来以后，我最自豪的一点其实是 **Terminal Tool**。  
因为它几乎等于把“人能在终端里做的事”直接交给了模型。

当时我甚至觉得：  
只要把白名单、沙盒、危险命令确认做好，模型就能像资深工程师一样操作仓库。

结果很快被现实教育了。

---

## 01｜我当时的设计：尽量放开自由度

在 V0 里，终端工具是这样初始化的（`code_agent/agentic/code_agent.py`）：

```python
self.terminal_tool = TerminalTool(
    workspace=str(self.paths.repo_root),
    timeout=60,
    confirm_dangerous=True,
    default_shell_mode=True,
)
```

这里的关键点是 `default_shell_mode=True`。  
这意味着模型不只是执行 `ls / rg / cat` 这种单条命令，而是可以直接写：

```
rg -n "foo" src/ | grep "class" | sed -n '1,120p'
```

对我来说，这个能力很诱人。  
它让模型能用一条命令完成多步操作，效率很高，也很“像人”。

为了让它看起来更安全，我还写了不少限制逻辑（`tools/builtin/terminal_tool.py`）：

- 只允许白名单命令（`rg/grep/find/cat/head/tail/sed` 等）；
- 高风险命令要显式 `allow_dangerous`；
- 禁止 `rm/chmod` 这类危险操作；
- 组合命令要经过安全检查；
- 需要写盘或命令替换时强制确认。

听起来很严密，对吧？  
但真正用起来，问题很快就暴露了。

---

## 02｜真实场景里，它开始“不可控”

最典型的一次踩坑是这样的：

我让 Agent “搜索某个类里的一个函数，并把实现片段展示出来”。  
模型给出了一条“非常聪明”的命令：

```
rg -n "TargetFunc" src/ | grep "class Foo" | sed -n '1,120p'
```

第一眼看，这就是老工程师常用的组合拳。  
但实际执行时，经常发生这些情况：

- `rg` 搜出来太多，`grep` 过滤后什么都不剩；  
- `rg` 因为权限/编码问题直接失败，后面的管道输入是空的；  
- `sed` 收到空输入，输出也空；  
- 最终模型看到的是“空结果”，但它不知道到底是哪一步出了问题。

这里的致命点是：  
**一条命令完成多步，错误被“压扁”了。**

模型只能看到最终失败，而看不到过程中的哪个环节出了问题。  
它自然也无法修正策略，只能“重新拍一条命令赌运气”。

---

## 03｜安全策略也很容易被组合绕开

我当时还以为白名单 + 沙盒 + 确认机制已经足够安全。  
但 shell 太灵活了，管道、重定向、子命令、逻辑组合全是“可绕过点”。

比如：

- 一条命令里混入 `>` 重定向，就变成了写盘行为；  
- `$(...)` 或反引号会触发子命令执行；  
- `cmd1 || cmd2` 这样的组合会把失败路径也带进来；  
- 即使你限制了 `rm`，依旧可能通过间接方式修改文件。

在 `terminal_tool.py` 里我写了很多安全检查逻辑：

```python
SHELL_META_TOKENS = ["|", "||", "&&", ";", ">", ">>", "<", "$(", "`"]
DANGEROUS_BASE_COMMANDS = {"rm", "chmod"}

if needs_allow and not allow_dangerous:
    return "❌ 该命令包含写盘/子命令替换/高风险操作..."
```

但现实问题是：  
**一旦你允许 shell 语法，你就永远在和组合复杂度做对抗。**

逻辑越写越长，模型越容易生成“刚好在边界上”的命令。  
而你又不能把所有组合都封死，否则能力会被直接砍成残废。

---

## 04｜最致命的问题：错误不可定位，模型不可纠错

我后来总结，Terminal Tool 的最大问题不是“不安全”，而是**不可诊断**。

在 Agent 体系里，模型需要通过“观察”来修正动作。  
但当一个 Action 里塞了 3~5 个子命令时：

- 观察结果只有一个；
- 失败信息是混在一起的；
- 模型无法知道是 `rg` 还是 `grep` 还是 `sed` 出错；
- 下一步只能凭猜测重新写一条更复杂的命令。

这会导致一个非常坏的循环：

**命令越来越长 → 失败越来越多 → 观察越来越模糊 → 修正越来越难。**

这也是我后来决定“拆工具”的真正原因。  
因为在 Agent 里，**可控性比一次性完成更重要**。

---

## 05｜这里我第一次意识到：自由不是能力上限

这一坑让我彻底转变了想法：

以前我以为“给模型自由度，就是提高能力上限”；  
后来我发现，“给模型自由度，往往是在放大不确定性”。

说白了，模型强是强，但它不是工程师。  
它会生成看起来很聪明的命令，但并不一定能稳定执行，更难自己定位问题。

所以这一章的结论是：

**在 Code Agent 场景里，Terminal Tool 不能只靠“白名单 + 沙盒”，  
更需要把复杂行为拆成一组可观测、可控的原子工具。**

下一章，我会讲我具体怎么把这些能力拆开，  
以及为什么主流 Code Agent 都走向了“工具化”而不是“脚本化”。**
