# 第1章：我为什么决定自己做一个 Code Agent

这两年，AI 编程助手火得一塌糊涂。  
GitHub Copilot、Cursor、Codex、Claude Code……工具一个比一个强。用自然语言描述需求，它就能写代码、改 Bug、跑测试，甚至帮你定位一些以前要排查半天的问题。

我也是重度用户。越用越觉得，真正把 Agentic 能力做出产品感的，最成功的一批基本都在 Code Agent 这条线上。

与此同时，Anthropic、OpenAI 这些前沿团队也在持续公开他们的 Agent 构建经验。虽然 Anthropic 的模型在国内有门槛，但他们的 Engineering Blog 我一直在看，每次读完都很上头：你会发现，真正拉开差距的不是“提示词写得多花”，而是工程设计是否扎实。

---

我做 MyCodeAgent 的直接起点，其实很朴素。

我学完了 Hello-Agent 的教程。教程最后有一个毕业设计：用学到的知识做一个自己的智能体应用。  
我当时就想，既然我日常高强度在用各种 Code Agent 产品，那不如就做一个自己的 Code Agent。  
一方面是兴趣，另一方面是我很清楚：**自己手搓一遍，才能真正理解这些产品为什么好用，以及它们到底在工程上做对了什么。**

于是我直接基于 Hello-Agent 开始动手。  
它给我的底子非常好：ReAct Agent、Tool Registry、Message 抽象、Terminal Tool……这些骨架是完整的。  
靠这套基础，我很快就做出了一个“能 ReAct、能操作文件”的原型。

那段时间我挺兴奋的，因为“从 0 到 1 跑通”这件事确实很爽。

---

但很快，问题就来了。

最典型的一次踩坑，出在终端能力设计上。  
作为 Code Agent，执行命令、搜索文件、查看代码片段、修改本地文件，这些能力是刚需。  
我当时的设计是：让模型直接输出完整 shell 命令，然后交给 Terminal Tool 执行。

我当时觉得这个方案很优雅：  
给模型足够自由，再配上黑白名单和目录沙盒，应该就够了。

结果测试很快打脸。

我让它“搜索某个类里的某个函数并展示出来”。模型生成了一条很长的命令：先 `rg` 全局搜索，再通过管道交给 `grep` 精筛，最后 `sed` 截取片段。  
第一眼看挺聪明，甚至有点惊艳——一条命令完成三步操作。

但问题也正是从这里开始的。

- 只要第一步 `rg` 因为范围过大、权限、编码等原因出问题，后面的输入就会变成空字符串或警告信息；  
- 第二步和第三步继续执行时，结果要么全空，要么报错；  
- 整体又是“一条命令一次观察”，模型只能看到最终失败，根本不知道是哪一步出了错；  
- 而且 shell 组合太灵活，管道、重定向、子命令拼起来，很容易绕开你写得不够严密的安全限制。

我后面复盘这类失败时，意识到我一开始高估了“给模型自由”的收益，也低估了“可控性”在工程里的重要性。

---

于是我停下来，反过来研究主流 Code Agent CLI 的设计——Claude Code、OpenCode、Gemini CLI 等等。

我看到一个非常一致的工程选择：  
它们会尽可能减少模型直接拼接不可控 shell 的空间，而是把能力拆成一个个可控工具，让模型用结构化参数去调用。

这背后其实是一个很关键的变化：

- 从“让模型一次性写一整段命令”  
  变成  
- “让模型每次只做一个动作，拿到一次观察，再决定下一步”

当模型每次只能调用一个工具时，你就能细粒度看到每一步是否成功；  
一旦失败，也能明确失败发生在第几步，然后立刻修正方向。  
这不是在“限制模型”，而是在给系统建立可靠的反馈回路。

我后来对 MyCodeAgent 的很多重构，都是沿着这条线展开的：  
协议标准化、上下文工程、工具熔断、子代理隔离、可观测性补齐……本质都在做同一件事：**把不确定性收敛到可控范围。**

---

到这里，我对“做 Agent”这件事的理解也彻底变了。

以前我会觉得，模型越自由越强；  
现在我更认同另一句话：

**Agent 开发的核心，不是让模型更自由，而是通过工程设计，把模型“不确定的能力”约束在“最小可控的范围”里。**

这也是我从 Hello-Agent 出发，走到 MyCodeAgent 的真正原因。  
下一章我会先讲一件经常被忽略但很关键的事：  
**我到底继承了 Hello-Agent 的哪些能力，又在哪些地方做了工程化增强。**
