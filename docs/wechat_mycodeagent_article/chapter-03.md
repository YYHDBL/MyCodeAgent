# 三、自由是把双刃剑：我的 Terminal Tool 是怎么失控的

V0 刚跑起来那会儿，我最自豪的其实是 **Terminal Tool**。

因为它几乎等于把"人能在终端里做的事"直接交给了模型。我当时甚至觉得——只要白名单、沙盒、危险命令确认做好，模型就能像资深工程师一样操作仓库。

结果很快被现实教育了。

---

## 1、我的设计：放开自由度，效率优先

V0 里的终端工具长这样：

```python
self.terminal_tool = TerminalTool(
    workspace=str(self.paths.repo_root),
    timeout=60,
    confirm_dangerous=True,
    default_shell_mode=True,  # 关键参数
)
```

`default_shell_mode=True` 意味着模型不只能执行 `ls`、`rg`、`cat` 这种单条命令，而是可以直接写：

```
rg -n "foo" src/ | grep "class" | sed -n '1,120p'
```

这个能力太诱人了。它让模型能用一条命令完成多步操作，效率很高，也很"像人"。

为了安全，我还加了不少限制：
- 只允许白名单命令
- 高风险操作要确认
- 禁止 `rm/chmod` 这类危险命令
- 组合命令要经过安全检查

听起来挺严密，对吧？

但真正用起来，问题很快就冒出来了。

---

## 2、真实场景：命令开始"不听话"

最典型的一次踩坑：

我让 Agent "搜索某个类里的函数，展示实现片段"。模型给出了一条"很聪明"的命令：

```
rg -n "TargetFunc" src/ | grep "class Foo" | sed -n '1,120p'
```

第一眼看，这就是老工程师常用的组合拳。但实际执行时，经常出现这些情况：

- `rg` 搜出来太多，`grep` 过滤后什么都没剩
- `rg` 因为权限或编码问题直接失败，管道输入是空的
- `sed` 收到空输入，输出也是空的
- 最终模型看到"空结果"，但它根本不知道哪一步出了问题

**最坑的是：一条命令完成多步，错误被"压扁"了。**

模型只能看到最终结果，看不到中间哪个环节挂了。它也没法修正策略，只能"重新拍一条命令赌运气"。

---

## 3、安全策略：越补越长的补丁战

我原以为白名单 + 沙盒 + 确认机制够安全了。但 shell 太灵活，管道、重定向、子命令全是"可绕过点"。

比如：
- `>` 重定向会变成写盘
- `$(...)` 触发子命令执行
- `cmd1 || cmd2` 把失败路径也带进来
- 即使限制了 `rm`，还可能间接改文件

我写了大量安全检查：

```python
SHELL_META_TOKENS = ["|", "||", "&&", ";", ">", ">>", "<", "$(", "`"]
DANGEROUS_BASE_COMMANDS = {"rm", "chmod"}

if needs_allow and not allow_dangerous:
    return "❌ 该命令包含写盘/子命令替换/高风险操作..."
```

但讲真，**一旦你允许 shell 语法，你就永远在和组合复杂度做对抗。**

逻辑越写越长，模型越容易生成"刚好在边界上"的命令。而你要是全封死，能力也就残了。

---

## 4、最致命的：错误不可定位，模型没法纠错

我后来总结，Terminal Tool 最大的问题不是"不安全"，而是**没法诊断**。

在 Agent 体系里，模型需要靠"观察"来修正动作。但一个 Action 里塞了 3~5 个子命令时：

- 观察结果只有一个
- 失败信息混在一起
- 模型根本不知道 `rg`、`grep`、`sed` 谁出了问题
- 下一步只能瞎猜着重写

这就形成了一个坏循环：

**命令越来越长 → 失败越来越多 → 观察越来越模糊 → 修正越来越难**

这也是我决定"拆工具"的真正原因。因为在 Agent 里，**可控性比一次性完成更重要**。

---

## 5、认知转变：自由不是能力上限

这一坑让我彻底转变了想法。

以前我觉得：给模型自由度 = 提高能力上限

后来我发现：**给模型自由度，往往是在放大不确定性**

说白了，模型强是强，但它不是工程师。它会生成看起来很聪明的命令，但并不一定能稳定执行，更难自己定位问题。

**这一章的结论：**

> Terminal Tool 不能只靠"白名单 + 沙盒"，更得把复杂行为拆成一组可观测、可控的原子工具。

---

**下一章**：我怎么把 Terminal Tool 拆开，以及为什么主流 Code Agent 都走向了"工具化"而不是"脚本化"。
