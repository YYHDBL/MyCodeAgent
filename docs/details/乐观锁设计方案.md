# Write 工具乐观锁实现方案（mtime + size）

## 目标

防止 Agent 在读取文件后、写入文件前，文件被用户或其他进程修改导致数据丢失。

## 场景

```
时间线：
T1: Agent 读取文件 (content=v1, mtime=t1, size=s1)
T2: 用户手动编辑 (content=v2, mtime=t2>t1, size=s2≠s1)
T3: Agent 写入 (基于 v1 的修改)
```

**风险**：T3 会覆盖用户的修改，丢失 v2。

---

## 方案：框架自动注入 + mtime/size 校验

### 核心设计

**模型无需手动传递 `expected_mtime_ms` / `expected_size_bytes`**，由框架（ToolRegistry）自动管理：

1. **Read 时**：框架自动缓存 `file_mtime_ms` 和 `file_size_bytes`
2. **Write 时**：框架自动从缓存注入这些参数
3. **校验失败**：返回 `CONFLICT` 错误，提示重新 Read

### 流程

```
1. Agent 调用 Read(path="file.py")
   → Read 返回: { stats: { file_mtime_ms: 1234567890000, file_size_bytes: 1024 } }
   → 框架自动缓存: _read_cache["file.py"] = {mtime, size, ...}

2. Agent 处理内容...

3. Agent 调用 Write(path="file.py", content="...")
   → 框架检测到 Write，自动注入:
     - expected_mtime_ms = 1234567890000
     - expected_size_bytes = 1024
   
4. Write 内部校验:
   current_mtime_ms = path.stat().st_mtime_ns // 1_000_000
   current_size_bytes = path.stat().st_size
   if current_mtime_ms != expected_mtime_ms or current_size_bytes != expected_size_bytes:
       return CONFLICT error
```

### 错误响应

```json
{
  "status": "error",
  "error": {
    "code": "CONFLICT",
    "message": "File has been modified since you read it. Please read it again to get the latest content."
  }
}
```

---

## 实现细节

### 1. ToolRegistry 维护 Read 缓存

```python
# tools/registry.py

class ReadMeta(TypedDict):
    path_resolved: str        # 解析后的规范化路径
    file_mtime_ms: int        # 文件修改时间（毫秒）
    file_size_bytes: int      # 文件大小（字节）
    captured_at: float        # 缓存时间戳

class ToolRegistry:
    def __init__(self):
        self._tools: dict[str, Tool] = {}
        self._functions: dict[str, dict[str, Any]] = {}
        self._read_cache: dict[str, ReadMeta] = {}  # 新增
```

### 2. execute_tool 自动记录 Read 结果

```python
def execute_tool(self, name: str, input_text) -> str:
    # ... 执行工具 ...
    
    # Read 完成后自动缓存
    if name == "Read":
        self._cache_read_meta(result_str, parameters)
    
    return result_str
```

### 3. 执行 Write/Edit 前自动注入

```python
def execute_tool(self, name: str, input_text) -> str:
    # 准备参数
    parameters = input_text.copy() if isinstance(input_text, dict) else {"input": input_text}
    
    # 为 Write/Edit 自动注入乐观锁参数
    if name in {"Write", "Edit"}:
        parameters = self._inject_optimistic_lock_params(name, parameters)
    
    # ... 执行工具 ...
```

### 4. WriteTool 校验逻辑（已实现）

```python
# tools/builtin/write_file.py

if abs_path.exists():
    # 已存在文件：要求提供期望值（由框架注入）
    if expected_mtime_ms is None or expected_size_bytes is None:
        return INVALID_PARAM error  # "请先 Read"
    
    # 校验文件是否被修改
    current_stat = abs_path.stat()
    if mtime/size 不匹配:
        return CONFLICT error
```

---

## 测试场景

| 场景 | 预期结果 |
|------|---------|
| 新文件（不需要 Read） | success |
| Read → Write（正常流程） | success（框架自动注入） |
| 直接 Write 已存在文件（未 Read） | INVALID_PARAM |
| Read 后文件被修改 → Write | CONFLICT |
| Read → 修改 → Write（手动传参） | success（兼容旧方式） |

---

## 注意事项

1. **mtime 精度**：使用毫秒（`st_mtime_ns // 1_000_000`），更稳定
2. **新文件**：创建新文件时不要求 mtime/size
3. **缓存隔离**：每个 ToolRegistry 实例独立缓存，避免跨会话污染
4. **dry_run**：同样执行冲突校验，避免基于过期内容生成 diff
5. **TOCTOU 缓解**：写入前二次校验，缩小竞态窗口
6. **向后兼容**：模型仍可手动传参，框架不覆盖已有值
7. **误报风险**：内容相同但 mtime 变化会触发误报（如 git checkout），这是保守策略，可接受

---

## 相关文件

| 文件 | 修改内容 |
|------|---------|
| `tools/registry.py` | 添加 `_read_cache`、自动注入/缓存逻辑 |
| `tools/base.py` | ErrorCode 添加 `CONFLICT` |
| `tools/builtin/read_file.py` | stats 返回 `file_mtime_ms` |
| `tools/builtin/write_file.py` | 乐观锁校验逻辑 |
| `prompts/tools_prompts/write_prompt.py` | 说明自动注入机制 |
| `tests/utils/protocol_validator.py` | VALID_ERROR_CODES 添加 `CONFLICT` |
